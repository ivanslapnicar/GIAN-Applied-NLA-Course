### A Pluto.jl notebook ###
# v0.10.0

using Markdown

# ╔═╡ 2bd4e64a-85a4-4726-aad7-01938b4d7edc
md"""
# Solutions 1 - Examples in Julia



## Assignment 1

The function `eps()` return the smallest real number larger than 1.0. It can be called for each of the `AbstractFloat` types. 

Functions `realmin()` and `realmax()` return the largest and the smallest positive numbers representable in the given type.
"""

# ╔═╡ d269847f-7f10-4935-84f0-b85707335159
?eps

# ╔═╡ 15ad5f2d-09ac-42ac-adf3-d48d5b4bf509
?realmax

# ╔═╡ 976a9e66-ad6c-42b3-939a-afa33c4dcfb8
subtypes(AbstractFloat)

# ╔═╡ 45e49a4e-f595-4d50-9bba-3d350962ee71
# Default values are for Float64
eps(), realmax(), realmin()

# ╔═╡ 11f7e114-56cb-4159-9404-1a1f0cb83798
T=Float32
eps(T), realmax(T), realmin(Float32)

# ╔═╡ c18adc14-b11e-400c-b74a-4063647de602
T=BigFloat
eps(T), realmax(T), realmin(T), map(Int64,round(log10(1/eps(T))*log(10)/log(2)))

# ╔═╡ acc500d1-3cdf-4c3f-86c6-985a0176ef7c
md"""
We see that `BigFloat` has approximately 77 significant decimal digits (actually 256 bits) and very large exponents. This makes the format ideal for Greaffe's method. 

Precision of `BigFloat` can be increased, but exponents do not change.
"""

# ╔═╡ 25b172d5-8ee1-479a-9621-dc9b02054fee
precision(BigFloat)

# ╔═╡ bb3f06e0-db79-4905-b23c-4d3eae8ec83a
setprecision(512)
eps(T), realmax(T)

# ╔═╡ 71652918-d91f-451b-80e8-5f59a2e6ce10
setprecision(256)

# ╔═╡ db19eb66-2ecb-4b47-929c-4369718373e1
md"""
Here is the function for the Graeffe's method. We also define small test polynomial with all real simple zeros.
"""

# ╔═╡ 80456803-2a40-40a3-adf5-b412cf132143
using Polynomials
p=poly([1,2,3,4])

# ╔═╡ c1531fcb-5e7f-4994-baf0-c12d1028ad2e
roots(p)

# ╔═╡ 60d365fa-907a-47f7-89cd-034215bd91e5
function Graeffe{T}(p::Poly{T},steps::Int64)
    # map the polynomial to BigFloat
    pbig=Poly(map(BigFloat,coeffs(p)))
    px=Poly([zero(BigFloat),one(BigFloat)])
    n=degree(p)
    σ=map(BigFloat,2^steps)
    for k=1:steps
        peven=Poly(coeffs(pbig)[1:2:end])
        podd=Poly(coeffs(pbig)[2:2:end])
        pbig=peven^2-podd^2*px 
    end
    # @show p[end]
    y=Array{BigFloat}(n)
    # Normalize if p is not monic
    y[1]=-pbig[end-1]/pbig[end]
    for k=2:n
        y[k]=-pbig[end-k]/pbig[end-(k-1)]
    end
    # Extract the roots
    for k=1:n
        y[k]=exp(log(y[k])/σ)
    end
    # Return root in Float64
    map(Float64,y)
end

# ╔═╡ b0e22007-d80a-4db0-8796-f3d28e735ddd
Graeffe(p,8)

# ╔═╡ a5ea266d-2406-4bd3-b5b6-0007f06fda60
md"""
Now the Wilkinson's polynomial:
"""

# ╔═╡ 28003bac-9ae8-4a6d-9073-830e0c47f8fa
ω=poly(collect(one(BigFloat):20))

# ╔═╡ 58b8dda8-c7f9-4f28-86c1-c7977e7418fa
Graeffe(ω,8)

# ╔═╡ d53d270d-063f-4e9d-9865-e746b5ed6012
ans[2]

# ╔═╡ 19dbd540-f872-4f74-a1f6-f742c2ac52f6
Graeffe(ω,16)

# ╔═╡ d9dfaece-dac1-45eb-a7b1-f158fba09ef8
ans[2]

# ╔═╡ 4d810eb7-d825-4f4a-a819-f00f38109eca
md"""
We now generate the Chebyshev polynomial $T_{50}(x)$ using the three term recurence.
"""

# ╔═╡ 729b1a27-da12-4158-a4a2-17767e7b272b
n=50
T0=Poly([BigInt(1)])
T1=Poly([0,1])
Tx=Poly([0,1])
for i=3:n+1
    T=2*Tx*T1-T0
    T0=T1
    T1=T
end

# ╔═╡ ef196b97-81c1-458b-8725-4864b770ff2c
T

# ╔═╡ 9d75f84a-dfda-43c2-9878-9f6bdf047adb
using Gadfly

# ╔═╡ 3247ea24-7e87-47da-a762-95bf28e07ee2
f(x)=T(x)

# ╔═╡ e32f5d08-fd9d-4a84-b209-f101df96586d
Gadfly.plot(f,-1,1)

# ╔═╡ 84d4bbf0-dffc-4e45-9759-abbaf2093525
md"""
In order to use Graeffe's method, we need to shift $T$ to the right by one, so that all roots have simple moduli, that is, we compute $T(1-x)$:
"""

# ╔═╡ e0dde918-8672-4124-ac42-aad9d3c3b2a9
Ts=T(Poly([BigFloat(1),-1]));

# ╔═╡ b2b74778-6ea2-4279-be80-7c3796e4e5f0
fs(x)=Ts(x)
Gadfly.plot(fs,0,2)

# ╔═╡ 5b793dcd-d176-48f8-bf1a-8c7c67b7acc4
# Computed roots, 16 steps are fine
y=Graeffe(Ts,16)-1

# ╔═╡ bc80699f-4b0a-4e11-9380-c22d9b79addd
# Exact roots
z=map(Float64,[cos((2*k-1)*pi/(2*n)) for k=1:n]);

# ╔═╡ 23227215-f509-436a-8bd1-4ebf530750dc
# Relative error
maximum(abs,(z-y)./z)

# ╔═╡ de733944-8938-4864-836e-501324fab73c
md"""
## Assignment 2

The key is that `/` works for block matrices, too. $A$ is overwritten and must therefore be copied at the beggining of the function, so that the original matrix is not overwritten.
"""

# ╔═╡ 73e29784-73c3-4eab-8e0c-05f87a135cd5
function mylu{T}(A1::Array{T}) # Strang, page 100
    A=copy(A1)
    n,m=size(A)
    for k=1:n-1
        for rho=k+1:n
            A[rho,k]=A[rho,k]/A[k,k]
            for l=k+1:n
                A[rho,l]=A[rho,l]-A[rho,k]*A[k,l]
            end
        end
    end
    # We return L and U
    L=tril(A,-1)
    U=triu(A)
    # This is the only difference for the block case
    for i=1:maximum(size(L))
        L[i,i]=one(L[1,1])
    end
    L,U
end

# ╔═╡ cefd4484-62a7-4640-ac97-b69b0122338c
A=rand(5,5)

# ╔═╡ 1af22159-7662-4259-9e74-50f2fbdfa104
L,U=mylu(A)

# ╔═╡ 0fbcbbe2-6461-4cb4-ba0a-8fb76b6ad8df
L*U-A

# ╔═╡ cd8ca823-9027-423b-a171-a7e84cdaf022
L

# ╔═╡ 09b776de-ad89-4503-8a45-3d6b635cb413
U

# ╔═╡ f9e9697b-702b-45ba-911c-409ff5a070ad
md"""
We now try block-matrices. First, a small example:
"""

# ╔═╡ 843bccd9-6546-4c91-9e94-ef9e894901bd
# Try k,l=32,16 i k,l=64,8
k,l=2,4
Ab=[rand(k,k) for i=1:l, j=1:l]

# ╔═╡ 7312297c-7515-4d49-a774-bfe01a77a126
Ab[1,1]

# ╔═╡ 3a51917a-d73c-4299-a79c-93ffee0a279f
L,U=mylu(Ab)

# ╔═╡ 5a4e9399-c48d-42aa-bd61-80f2e5011ddc
L[1,1]

# ╔═╡ f230dbc0-6cea-436a-a16e-c1e10dadfb8c
# Residual
R=L*U-Ab

# ╔═╡ d5bdff29-d7e3-4c7b-a60c-eea6d0d60ded
norm(R) # This is not defined

# ╔═╡ c5cc2992-8a2b-49fd-96e8-037d2115e112
vecnorm(R)

# ╔═╡ 18b0e85f-30f2-494b-bb0c-4266c2198c37
md"""
We need a convenience function to unblock the block-matrix:
"""

# ╔═╡ 22f0e9a0-e8c7-4d9c-ba82-710031783c33
unblock(A) = mapreduce(identity, hcat, 
    [mapreduce(identity, vcat, A[:,i]) for i = 1:size(A,2)])

# ╔═╡ 6f89a481-59a1-40e9-9f1d-55d85d429289
unblock(Ab)

# ╔═╡ 3ed005ae-6c17-4fb5-97a5-24e3a9db7a02
norm(unblock(L*U-Ab))

# ╔═╡ a56877b1-6f3d-4b43-ac46-63f0ea49eeab
md"""
We now compute timings and errors for bigger example:
"""

# ╔═╡ adc8ac36-b15d-4c38-9690-84fd7f9ccd97
# This is 512x512 matrix consisting of 16x16 blocks of dimension 32x32
k,l=32,16
Ab=[rand(k,k) for i=1:l, j=1:l]
# Unblocked version
A=unblock(Ab);

# ╔═╡ 6f0f8746-2b03-4380-b4c1-34eb3c824a18
?lu

# ╔═╡ 3e92ec3e-ba0d-45fb-8d2a-34b75aedbe74
# Built-in LAPACK function with pivoting 
@time L,U,p=lu(A);

# ╔═╡ ad94b447-8da3-4b3a-9fb6-444bce069dca
norm(L*U-A[p,:])

# ╔═╡ cb75c7a3-e759-427c-9a8c-6355d3136a60
# mylu() unblocked
@time L,U=mylu(A);

# ╔═╡ bf65007f-8b71-4e68-bd2e-2e7b478a55d2
norm(L*U-A)

# ╔═╡ f353ff53-f57b-406e-bc6f-32e50664d6f4
# mylu() on a block-matrix - much faster, but NO pivoting
@time L,U=mylu(Ab);

# ╔═╡ b6335aad-75b9-4035-804e-159749c59b5b
norm(unblock(L*U-Ab))

# ╔═╡ fc06fbd7-56e0-4ec5-af90-52626de2ee4a
md"""
## Assignment 3
"""

# ╔═╡ f5aba686-9704-4d5d-9113-165f9e24172f
using Winston

# ╔═╡ 022d3ee4-0c3d-467a-a64b-5d9ada7b489f
k=20
n=20
E=Array{Any}(n,k)
# Unsymmetrix random uniform distribution
for i=1:k
    A=rand(n,n)
    E[:,i]=eigvals(A)
end
# We need this since plot cannot handle `Any`
E=map(eltype(E[1,1]),E)

# ╔═╡ 92e27997-3df3-44b7-ad5d-154f4e7bb413
Winston.plot(E,"*")

# ╔═╡ 3c882f05-359e-4ed0-9949-2b83229867f1
# Unsymmetric random normal distribution
E=Array{Any}(n,k)
for i=1:k
    A=randn(n,n)
    E[:,i]=eigvals(A)
end
# We need this for plot to work
E=map(eltype(E[1,1]),E)
Winston.plot(E,"*")

# ╔═╡ 91664262-a4e8-4cdc-86eb-0e725df3fd58
# Symmetric random uniform distribution
E=Array{Any}(n,k)
for i=1:k
    A=rand(n,n)
    A=triu(A)+triu(A,1)'
    E[:,i]=eigvals(A)
end
# We need this for plot to work
E=map(eltype(E[1,1]),E)
Winston.plot(E,"*")

# ╔═╡ bed05ec5-34bd-40f8-ad2d-2be64175d31a
# Symmetric random normal distribution
E=Array{Any}(n,k)
for i=1:k
    A=randn(n,n)
    A=triu(A)+triu(A,1)'
    E[:,i]=eigvals(A)
end
# We need this for plot to work
E=map(eltype(E[1,1]),E)
Winston.plot(E,"*")

# ╔═╡ 23c46f3f-60ab-4f8f-94f3-99bb01c91934
# Now the interactive partcxx
using Interact

# ╔═╡ 4b89e7b8-34a2-46bc-ad1b-8b0ff85312b3
@manipulate for k=10:30, n=10:30
    E=Array{Any}(n,k)
    for i=1:k
        A=randn(n,n)
        A=triu(A)+triu(A,1)'
        E[:,i]=eigvals(A)
    end
    # We need this for plot to work
    E=map(eltype(E[1,1]),E)
    Winston.plot(E,"*")
end

# ╔═╡ c3edd1f6-87a9-462d-8fe2-88b971a62c7a
md"""
_Mathematics is about spotting patterns!_ (Alan Edelman)
"""

# ╔═╡ b069b405-53b4-45e5-ad2c-b29114a8bddd


# ╔═╡ Cell order:
# ╟─2bd4e64a-85a4-4726-aad7-01938b4d7edc
# ╠═d269847f-7f10-4935-84f0-b85707335159
# ╠═15ad5f2d-09ac-42ac-adf3-d48d5b4bf509
# ╠═976a9e66-ad6c-42b3-939a-afa33c4dcfb8
# ╠═45e49a4e-f595-4d50-9bba-3d350962ee71
# ╠═11f7e114-56cb-4159-9404-1a1f0cb83798
# ╠═c18adc14-b11e-400c-b74a-4063647de602
# ╟─acc500d1-3cdf-4c3f-86c6-985a0176ef7c
# ╠═25b172d5-8ee1-479a-9621-dc9b02054fee
# ╠═bb3f06e0-db79-4905-b23c-4d3eae8ec83a
# ╠═71652918-d91f-451b-80e8-5f59a2e6ce10
# ╟─db19eb66-2ecb-4b47-929c-4369718373e1
# ╠═80456803-2a40-40a3-adf5-b412cf132143
# ╠═c1531fcb-5e7f-4994-baf0-c12d1028ad2e
# ╠═60d365fa-907a-47f7-89cd-034215bd91e5
# ╠═b0e22007-d80a-4db0-8796-f3d28e735ddd
# ╟─a5ea266d-2406-4bd3-b5b6-0007f06fda60
# ╠═28003bac-9ae8-4a6d-9073-830e0c47f8fa
# ╠═58b8dda8-c7f9-4f28-86c1-c7977e7418fa
# ╠═d53d270d-063f-4e9d-9865-e746b5ed6012
# ╠═19dbd540-f872-4f74-a1f6-f742c2ac52f6
# ╠═d9dfaece-dac1-45eb-a7b1-f158fba09ef8
# ╟─4d810eb7-d825-4f4a-a819-f00f38109eca
# ╠═729b1a27-da12-4158-a4a2-17767e7b272b
# ╠═ef196b97-81c1-458b-8725-4864b770ff2c
# ╠═9d75f84a-dfda-43c2-9878-9f6bdf047adb
# ╠═3247ea24-7e87-47da-a762-95bf28e07ee2
# ╠═e32f5d08-fd9d-4a84-b209-f101df96586d
# ╟─84d4bbf0-dffc-4e45-9759-abbaf2093525
# ╠═e0dde918-8672-4124-ac42-aad9d3c3b2a9
# ╠═b2b74778-6ea2-4279-be80-7c3796e4e5f0
# ╠═5b793dcd-d176-48f8-bf1a-8c7c67b7acc4
# ╠═bc80699f-4b0a-4e11-9380-c22d9b79addd
# ╠═23227215-f509-436a-8bd1-4ebf530750dc
# ╟─de733944-8938-4864-836e-501324fab73c
# ╠═73e29784-73c3-4eab-8e0c-05f87a135cd5
# ╠═cefd4484-62a7-4640-ac97-b69b0122338c
# ╠═1af22159-7662-4259-9e74-50f2fbdfa104
# ╠═0fbcbbe2-6461-4cb4-ba0a-8fb76b6ad8df
# ╠═cd8ca823-9027-423b-a171-a7e84cdaf022
# ╠═09b776de-ad89-4503-8a45-3d6b635cb413
# ╟─f9e9697b-702b-45ba-911c-409ff5a070ad
# ╠═843bccd9-6546-4c91-9e94-ef9e894901bd
# ╠═7312297c-7515-4d49-a774-bfe01a77a126
# ╠═3a51917a-d73c-4299-a79c-93ffee0a279f
# ╠═5a4e9399-c48d-42aa-bd61-80f2e5011ddc
# ╠═f230dbc0-6cea-436a-a16e-c1e10dadfb8c
# ╠═d5bdff29-d7e3-4c7b-a60c-eea6d0d60ded
# ╠═c5cc2992-8a2b-49fd-96e8-037d2115e112
# ╟─18b0e85f-30f2-494b-bb0c-4266c2198c37
# ╠═22f0e9a0-e8c7-4d9c-ba82-710031783c33
# ╠═6f89a481-59a1-40e9-9f1d-55d85d429289
# ╠═3ed005ae-6c17-4fb5-97a5-24e3a9db7a02
# ╟─a56877b1-6f3d-4b43-ac46-63f0ea49eeab
# ╠═adc8ac36-b15d-4c38-9690-84fd7f9ccd97
# ╠═6f0f8746-2b03-4380-b4c1-34eb3c824a18
# ╠═3e92ec3e-ba0d-45fb-8d2a-34b75aedbe74
# ╠═ad94b447-8da3-4b3a-9fb6-444bce069dca
# ╠═cb75c7a3-e759-427c-9a8c-6355d3136a60
# ╠═bf65007f-8b71-4e68-bd2e-2e7b478a55d2
# ╠═f353ff53-f57b-406e-bc6f-32e50664d6f4
# ╠═b6335aad-75b9-4035-804e-159749c59b5b
# ╟─fc06fbd7-56e0-4ec5-af90-52626de2ee4a
# ╠═f5aba686-9704-4d5d-9113-165f9e24172f
# ╠═022d3ee4-0c3d-467a-a64b-5d9ada7b489f
# ╠═92e27997-3df3-44b7-ad5d-154f4e7bb413
# ╠═3c882f05-359e-4ed0-9949-2b83229867f1
# ╠═91664262-a4e8-4cdc-86eb-0e725df3fd58
# ╠═bed05ec5-34bd-40f8-ad2d-2be64175d31a
# ╠═23c46f3f-60ab-4f8f-94f3-99bb01c91934
# ╠═4b89e7b8-34a2-46bc-ad1b-8b0ff85312b3
# ╟─c3edd1f6-87a9-462d-8fe2-88b971a62c7a
# ╠═b069b405-53b4-45e5-ad2c-b29114a8bddd
